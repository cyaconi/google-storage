http://github.com/nicksieger/multipart-post

BOUNDARY = "AaB03x" 
def encode_multipartformdata(parameters = {}) 
  ret = String.new 
  parameters.each do |key, value| 
    unless value.empty? 
      ret << "\r\n--" << BOUNDARY << "\r\n" 
      ret << "Content-Disposition: form-data; name=\"#{key}\"\r\n\r\n" 
      ret << value 
    end 
  end 
  ret << "\r\n--" << BOUNDARY << "--\r\n" 
end


EOL = "\015\012"  # "\r\n" 
# Encode params and image in multipart/form-data. 
def encode_multipart params,image_param,image_file_path,content_type 
  headers={} 
  parts=[] 
  boundary="----234092834029834092830498" 
  params.each_pair do |key,val| 
    parts.push %{Content-Disposition: form-data; }+ 
               %{name="#{key}"#{EOL}#{EOL}#{val}#{EOL}} 
  end 
  image_part = \ 
    %{Content-Disposition: form-data; name="#{image_param}"; }+ 
    %{filename="#{File.basename(image_file_path)}"#{EOL}}+ 
    %{Content-Type: #{content_type}#{EOL}#{EOL}} 
  image_part << File.read(image_file_path) << EOL 
  parts.push image_part 
  body = parts.join("--#{boundary}#{EOL}") 
  body = "--#{boundary}#{EOL}" + body + "--#{boundary}--"+EOL 
  headers['Content-Type']="multipart/form-data; boundary=#{boundary}" 
  #headers['Content-Length']=body.size 
  [ headers , body ] 
end

# Takes a hash of string and file parameters and returns a string of text
# formatted to be sent as a multipart form post.
#
# Author:: Cody Brimhall <mailto:cbrimhall@ucdavis.edu>
# Created:: 22 Feb 2008

require 'rubygems'
require 'mime/types'
require 'cgi'


module Multipart
  VERSION = "1.0.0" unless const_defined?(:VERSION)

  # Formats a given hash as a multipart form post
  # If a hash value responds to :string or :read messages, then it is
  # interpreted as a file and processed accordingly; otherwise, it is assumed
  # to be a string
  class Post
    # We have to pretend like we're a web browser...
    USERAGENT = "Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en-us) AppleWebKit/523.10.6 (KHTML, like Gecko) Version/3.0.4 Safari/523.10.6" unless const_defined?(:USERAGENT)
    BOUNDARY = "0123456789ABLEWASIEREISAWELBA9876543210" unless const_defined?(:BOUNDARY)
    CONTENT_TYPE = "multipart/form-data; boundary=#{ BOUNDARY }" unless const_defined?(:CONTENT_TYPE)
    HEADER = { "Content-Type" => CONTENT_TYPE, "User-Agent" => USERAGENT } unless const_defined?(:HEADER)

    def self.prepare_query(params)
      fp = []

      params.each do |k, v|
        # Are we trying to make a file parameter?
        if v.respond_to?(:path) and v.respond_to?(:read) then
          fp.push(FileParam.new(k, v.path, v.read))
        # We must be trying to make a regular parameter
        else
          fp.push(StringParam.new(k, v))
        end
      end

      # Assemble the request body using the special multipart format
      query = fp.collect {|p| "--" + BOUNDARY + "\r\n" + p.to_multipart }.join("")  + "--" + BOUNDARY + "--"
      return query, HEADER
    end
  end

  private

  # Formats a basic string key/value pair for inclusion with a multipart post
  class StringParam
    attr_accessor :k, :v

    def initialize(k, v)
      @k = k
      @v = v
    end

    def to_multipart
      return "Content-Disposition: form-data; name=\"#{CGI::escape(k)}\"\r\n\r\n#{v}\r\n"
    end
  end

  # Formats the contents of a file or string for inclusion with a multipart
  # form post
  class FileParam
    attr_accessor :k, :filename, :content

    def initialize(k, filename, content)
      @k = k
      @filename = filename
      @content = content
    end

    def to_multipart
      # If we can tell the possible mime-type from the filename, use the
      # first in the list; otherwise, use "application/octet-stream"
      mime_type = MIME::Types.type_for(filename)[0] || MIME::Types["application/octet-stream"][0]
      return "Content-Disposition: form-data; name=\"#{CGI::escape(k)}\"; filename=\"#{ filename }\"\r\n" +
             "Content-Type: #{ mime_type.simplified }\r\n\r\n#{ content }\r\n"
    end
  end
end



require 'nokogiri'

b1 = Nokogiri::XML::Builder.new(:encoding => 'UTF-8') do |xml|
 xml.html{
   xml.body{
     xml.h1("header1")
     xml.h2("header2")
   }
 }
end
b2 = Nokogiri::XML::Builder.new(:encoding => 'UTF-8') do |xml|
 xml.html{
   xml.body{
     xml.h3("header3")
     xml.h4("header4")
   }
 }
end

doc1 = Nokogiri::XML(b1.to_xml)
doc2 = Nokogiri::XML(b2.to_xml)

doc1.root.at("body").add_child(doc2.xpath("//h3"))
doc1.root.at("body").add_child(doc2.xpath("//h4"))
puts doc1.to_xml(:indent => 3)


